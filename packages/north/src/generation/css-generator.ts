import { createHash } from "node:crypto";
import type { NorthConfig } from "../config/schema.ts";
import { generateColorTokens, generateShadcnAliases, generateSurfaceTokens } from "./colors.ts";
import { generateTokensFromConfig } from "./dials.ts";

// ============================================================================
// CSS Generation
// ============================================================================

export interface GeneratedCSS {
  content: string;
  checksum: string;
}

/**
 * Generate SHA-256 checksum of CSS content
 */
function generateChecksum(content: string): string {
  return createHash("sha256").update(content).digest("hex");
}

/**
 * Generate file header with checksum
 */
function generateHeader(checksum: string): string {
  return `/**
 * North Design System Tokens
 * Checksum: ${checksum}
 *
 * DO NOT EDIT THIS FILE MANUALLY
 * Generated by: north gen
 * Regenerate: north gen
 */

`;
}

/**
 * Format CSS tokens as key-value pairs
 */
function formatTokens(tokens: Record<string, string>, indent = "  "): string {
  return Object.entries(tokens)
    .map(([key, value]) => `${indent}${key}: ${value};`)
    .join("\n");
}

/**
 * Generate Tailwind v4 @theme block with literal values
 */
function generateThemeBlock(config: NorthConfig): string {
  const tokens = generateTokensFromConfig(config);
  const colorTokens = generateColorTokens(config.colors);
  const surfaceTokens = generateSurfaceTokens();

  const allTokens = {
    // Colors (with --color- prefix for Tailwind utilities)
    ...colorTokens,
    ...surfaceTokens,

    // Spacing
    ...tokens.spacing,

    // Radius
    ...tokens.radius,

    // Shadows
    ...tokens.shadows,

    // Density/Controls
    ...tokens.density,

    // Typography
    ...tokens.typography,

    // Layout
    ...tokens.layout,
  };

  return `@theme {
${formatTokens(allTokens)}
}`;
}

/**
 * Generate :root block with shadcn aliases
 */
function generateRootBlock(): string {
  const aliases = generateShadcnAliases();

  return `:root {
${formatTokens(aliases)}
}`;
}

/**
 * Generate dark mode overrides (placeholder for v0.1)
 */
function generateDarkModeBlock(): string {
  return `.dark {
  /* Dark mode color overrides will be added in Phase 2 */
}`;
}

/**
 * Generate complete CSS file
 */
export function generateCSS(config: NorthConfig): GeneratedCSS {
  // Generate blocks
  const themeBlock = generateThemeBlock(config);
  const rootBlock = generateRootBlock();
  const darkModeBlock = generateDarkModeBlock();

  // Combine into full CSS
  const cssContent = [themeBlock, "", rootBlock, "", darkModeBlock].join("\n");

  // Generate checksum
  const checksum = generateChecksum(cssContent);

  // Add header with checksum
  const header = generateHeader(checksum);
  const content = `${header + cssContent}\n`;

  return {
    content,
    checksum,
  };
}

// ============================================================================
// Checksum Verification
// ============================================================================

export interface ChecksumVerificationResult {
  valid: boolean;
  currentChecksum?: string;
  expectedChecksum?: string;
  message: string;
}

/**
 * Extract checksum from generated CSS file
 */
export function extractChecksumFromCSS(cssContent: string): string | undefined {
  const checksumMatch = cssContent.match(/Checksum:\s*([a-f0-9]{64})/i);
  return checksumMatch ? checksumMatch[1] : undefined;
}

/**
 * Verify checksum of CSS content
 */
export function verifyChecksum(cssContent: string): ChecksumVerificationResult {
  // Extract expected checksum from header
  const expectedChecksum = extractChecksumFromCSS(cssContent);

  if (!expectedChecksum) {
    return {
      valid: false,
      message: "No checksum found in file. File may not be generated by North.",
    };
  }

  // Extract CSS content (everything after header)
  const headerEnd = cssContent.indexOf("@theme");
  if (headerEnd === -1) {
    return {
      valid: false,
      expectedChecksum,
      message: "Invalid CSS format. @theme block not found.",
    };
  }

  // Get content without header (but preserve trailing newline if present)
  let contentWithoutHeader = cssContent.slice(headerEnd);
  // Remove trailing newline that was added during file generation
  if (contentWithoutHeader.endsWith("\n")) {
    contentWithoutHeader = contentWithoutHeader.slice(0, -1);
  }

  // Generate checksum of actual content
  const currentChecksum = generateChecksum(contentWithoutHeader);

  if (currentChecksum === expectedChecksum) {
    return {
      valid: true,
      currentChecksum,
      expectedChecksum,
      message: "Checksum valid. File has not been modified.",
    };
  }

  return {
    valid: false,
    currentChecksum,
    expectedChecksum,
    message:
      "Checksum mismatch. File has been modified since generation. Run 'north gen' to regenerate.",
  };
}
